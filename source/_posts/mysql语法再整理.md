---
title: mysql语法再整理
date: 2023-06-18 17:13:15
tags: Mysql
toc: true
---
- [mysql语法学习](#mysql语法学习)
  - [理论基础](#理论基础)
    - [多表连接](#多表连接)
      - [内连接](#内连接)
      - [外连接](#外连接)
      - [交叉连接](#交叉连接)
  - [常规例题](#常规例题)
    - [leetcode-数据库-175-组合两个表](#leetcode-数据库-175-组合两个表)
    - [leetcode-数据库-181-超过经理收入的员工](#leetcode-数据库-181-超过经理收入的员工)
    - [leetcode-数据库-182-查找重复的电子邮箱](#leetcode-数据库-182-查找重复的电子邮箱)
    - [leetcode-数据库-183-从不订购的客户](#leetcode-数据库-183-从不订购的客户)
    - [leetcode-数据库-196-删除重复的电子邮箱](#leetcode-数据库-196-删除重复的电子邮箱)
    - [leetcode-数据库-197-上升的温度](#leetcode-数据库-197-上升的温度)
    - [leetcode-数据库-511-游戏玩法分析Ⅰ](#leetcode-数据库-511-游戏玩法分析ⅰ)
    - [leetcode-数据库-577-员工奖金](#leetcode-数据库-577-员工奖金)
    - [leetcode-数据库-584-寻找用户推荐人](#leetcode-数据库-584-寻找用户推荐人)
    - [leetcode-数据库-586-订单最多的用户](#leetcode-数据库-586-订单最多的用户)
    - [leetcode-数据库-595-大的国家](#leetcode-数据库-595-大的国家)
    - [leetcode-数据库-596-超过5名学生的课](#leetcode-数据库-596-超过5名学生的课)
    - [leetcode-数据库-1141-查询近30天活跃用户](#leetcode-数据库-1141-查询近30天活跃用户)
    - [leetcode-数据库-1633-各赛事的用户注册率](#leetcode-数据库-1633-各赛事的用户注册率)
    - [leetcode-数据库-1527-患某种疾病的患者](#leetcode-数据库-1527-患某种疾病的患者)
    - [leetcode-数据库-610-判断三角形](#leetcode-数据库-610-判断三角形)
    - [leetcode-数据库-1407-排名靠前的旅行者](#leetcode-数据库-1407-排名靠前的旅行者)
    - [leetcode-数据库-1731-每名经理的下属员工数量](#leetcode-数据库-1731-每名经理的下属员工数量)
    - [leetcode-数据库-1484-按日期分组销售产品](#leetcode-数据库-1484-按日期分组销售产品)
    - [leetcode-数据库-1517-查找拥有有效邮箱的用户](#leetcode-数据库-1517-查找拥有有效邮箱的用户)

# mysql语法学习
<!-- more -->
## 理论基础

### 多表连接

#### 内连接

---

a表：

|  id  | age  |
| :--: | :--: |
|  1   |  18  |
|  2   |  19  |
|  3   |  20  |

b表：

|  id  |   表头   |
| :--: | :------: |
|  2   |  xiaoer  |
|  3   | zhangsan |
|  4   |   lisi   |

- 关键字：inner join 或 join 

- 得到满足某一条件下的A、B内部共同有的数据

- 会把A、B所有交叠的信息全部保留下来，包括id列。所以就==可能会出现两个id列==。

  - ```
    select a.*,b.*
    from a
    join b
    on a.id = b.id;
    ```

  - 结果：

  - |  id  | age  | id(1) |   name   |
    | :--: | :--: | :---: | :------: |
    |  2   |  19  |   2   |  xiaoer  |
    |  3   |  20  |   3   | zhangsan |

- 注意：

   -  一般都要加上on使用，，否则会被解释为交叉连接

####  外连接

1. 左连接

   - 关键字：left join 或者 left outer join

   - 得到的结果是A中所有数据+B中符合某一条件下的数据。若A中的数据在B中找不到对应合适的数据项，会置为null

   - ```
     select a.*,b.*
     from a
     left join b
     on a.id = b.id;
     ```

   - 结果：

   - |  id  | age  | id(1) |   name   |
     | :--: | :--: | :---: | :------: |
     |  1   |  18  | NULL  |   NULL   |
     |  2   |  19  |   2   |  xiaoer  |
     |  3   |  20  |   3   | zhangsan |

2. 左连接+where b.clumn is null

   - 关键字：left join 或者 left outer join+where b.clumn is null

   - 得到的结果是A中的数据“减去”B中符合该条件下的数据后剩下的数据

   - ```
     select a.*,b.*
     from a
     left join b
     on a.id = b.id
     where b.id is null;
     ```

   - 结果：

   - |  id  | age  | id(1) | name |
     | :--: | :--: | :---: | :--: |
     |  1   |  18  | NULL  | NULL |

3. 右连接

   - 关键字：right join 或者 right outer join

   - 得到的是B中所有数据+A中符合某条件下的数据，若A中没有满足B中的数据项则置为NULL

   - ```
     select a.*,b.*
     from a
     right join b
     on a.id = b.id;
     ```

   - 结果

   - |  id  | age  | id(1) |   name   |
     | :--: | :--: | :---: | :------: |
     |  2   |  19  |   2   |  xiaoer  |
     |  3   |  20  |   3   | zhangsan |
     | NULL | NULL |   4   |   lisi   |

4. 右连接+where is null 

   - 关键字：right join 或者 right outer join+where a.clumn is null

   - 得到的是B中所有数据“减去”A中符合某条件的数据剩下的数据项

   - ```
     select a.*,b.*
     from a
     right join b
     on a.id = b.id
     where a.id is null;
     ```

   - 结果：

   - |  id  | age  | id(1) | name  |
     | :--: | :--: | :---: | :---: |
     | NULL | NULL |   4   | lisi4 |

5.  left join + nuion + right join（sql中的full union）

   - 关键字：left join   nuion   right join

   - union后重复的数据项会合并

   - 得到A和B满足条件下所有数据项，A中没有B的对用数据或者B中没有A中对应数据的数据项会被置为空

   - ```
     select a.*,b.*
     from a
     left join b
     on a.id = b.id
     union
     select a.*,b.*
     from a
     right join b
     on a.id = b.id;
     ```

   - 结果：

   - |  id  | age  | id(1) |   name   |
     | :--: | :--: | :---: | :------: |
     |  1   |  18  | NULL  |   NULL   |
     |  2   |  19  |   2   |  xiaoer  |
     |  3   |  20  |   3   | zhangsan |
     | NULL | NULL |   4   |   lisi   |

6.  (left join + where a.clumn is null) nuion + (right join+where b.clumn is null)（sql中的full union）

   - 关键字：left join  where a.clumn is null   nuion   right join where b.clumn is null

   - 得到的A、B中不满足某一条件的各自剩下的数据项

   - ```
     select a.*,b.*
     from a
     left join b
     on a.id = b.id
     where b.id is null
     union
     select a.*,b.*
     from a
     right join b
     on a.id = b.id
     where a.id is null;
     ```

   - 结果：

   - |  id  | age  | id(1) | name |
     | :--: | :--: | :---: | :--: |
     |  1   |  18  | NULL  | NULL |
     | NULL | NULL |   4   | lisi |

#### 交叉连接

1. 笛卡尔积

   -  关键字：cross join

   - 得到符合某一条件下A各项与B各项的==全排列组合==

   - ```
     select a.*,b.*
     from a
     cross join b
     ```

   - 结果：

   - |  id  | age  | id(1) |   name   |
     | :--: | :--: | :---: | :------: |
     |  1   |  18  |   2   |  xiaoer  |
     |  2   |  19  |   2   |  xiaoer  |
     |  3   |  20  |   2   |  xiaoer  |
     |  1   |  18  |   3   | zhangsan |
     |  2   |  19  |   3   | zhangsan |
     |  3   |  20  |   3   | zhangsan |
     |  1   |  18  |   4   |   lisi   |
     |  2   |  19  |   4   |   lisi   |
     |  3   |  20  |   4   |   lisi   |

2. cross join + where

   - 关键字：cross join   where

   - 等价于 内连接

   - 满足某一条件下的A、B内部共同有的数据

   - ```
     select a.*,b.*
     from a
     cross join b
     where a.id = b.id;
     ```

   - 结果：

   - |  id  | age  | id(1) |   name   |
     | :--: | :--: | :---: | :------: |
     |  2   |  19  |   2   |  xiaoer  |
     |  3   |  20  |   3   | zhangsan |

   - 注意：cross join + on 也会被解释为cross join +where



## 常规例题

### leetcode-数据库-175-组合两个表

- 题意

  表: `Person`

  ```
  +-------------+---------+
  | 列名         | 类型     |
  +-------------+---------+
  | PersonId    | int     |
  | FirstName   | varchar |
  | LastName    | varchar |
  +-------------+---------+
  personId 是该表的主键（具有唯一值的列）。
  该表包含一些人的 ID 和他们的姓和名的信息。
  ```

  表: `Address`

  ```
  +-------------+---------+
  | 列名         | 类型    |
  +-------------+---------+
  | AddressId   | int     |
  | PersonId    | int     |
  | City        | varchar |
  | State       | varchar |
  +-------------+---------+
  addressId 是该表的主键（具有唯一值的列）。
  该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。
  ```

  编写解决方案，报告 `Person` 表中每个人的姓、名、城市和州。如果 `personId` 的地址不在 `Address` 表中，则报告为 `null` 。

  以 **任意顺序** 返回结果表。

  结果格式如下所示。

  **示例 1:**

  ```
  输入: 
  Person表:
  +----------+----------+-----------+
  | personId | lastName | firstName |
  +----------+----------+-----------+
  | 1        | Wang     | Allen     |
  | 2        | Alice    | Bob       |
  +----------+----------+-----------+
  Address表:
  +-----------+----------+---------------+------------+
  | addressId | personId | city          | state      |
  +-----------+----------+---------------+------------+
  | 1         | 2        | New York City | New York   |
  | 2         | 3        | Leetcode      | California |
  +-----------+----------+---------------+------------+
  输出: 
  +-----------+----------+---------------+----------+
  | firstName | lastName | city          | state    |
  +-----------+----------+---------------+----------+
  | Allen     | Wang     | Null          | Null     |
  | Bob       | Alice    | New York City | New York |
  +-----------+----------+---------------+----------+
  解释: 
  地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。
  addressId = 1 包含了 personId = 2 的地址信息。
  ```

- 解答示例：

  ```
  SELECT person.firstname,person.lastName,address.city,address.state
  FROM  person  
  LEFT JOIN  address
  on person.personId = address.personId;
  ```

### leetcode-数据库-181-超过经理收入的员工

- 题意

  表：`Employee` 

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | name        | varchar |
  | salary      | int     |
  | managerId   | int     |
  +-------------+---------+
  id 是该表的主键（具有唯一值的列）。
  该表的每一行都表示雇员的ID、姓名、工资和经理的ID。
  ```

  编写解决方案，找出收入比经理高的员工。

  以 **任意顺序** 返回结果表。

  结果格式如下所示。

  **示例 1:**

  ```
  输入: 
  Employee 表:
  +----+-------+--------+-----------+
  | id | name  | salary | managerId |
  +----+-------+--------+-----------+
  | 1  | Joe   | 70000  | 3         |
  | 2  | Henry | 80000  | 4         |
  | 3  | Sam   | 60000  | Null      |
  | 4  | Max   | 90000  | Null      |
  +----+-------+--------+-----------+
  输出: 
  +----------+
  | Employee |
  +----------+
  | Joe      |
  +----------+
  解释: Joe 是唯一挣得比经理多的雇员。
  ```

- 解答示例：

  ```
  SELECT a.`name` Employee from employee a
  JOIN employee b
  on a.managerId = b.id
  WHERE a.salary > b.salary
  ```

- 要点：注意关键字优先级： where > group by > having > oder by

### leetcode-数据库-182-查找重复的电子邮箱

- 题意

  表: `Person`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | email       | varchar |
  +-------------+---------+
  id 是该表的主键（具有唯一值的列）。
  此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。
  ```

  编写解决方案来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。

  以 **任意顺序** 返回结果表。

  结果格式如下例。

  **示例 1:**

  ```
  输入: 
  Person 表:
  +----+---------+
  | id | email   |
  +----+---------+
  | 1  | a@b.com |
  | 2  | c@d.com |
  | 3  | a@b.com |
  +----+---------+
  输出: 
  +---------+
  | Email   |
  +---------+
  | a@b.com |
  +---------+
  解释: a@b.com 出现了两次。
  ```

- 解答示例
- 要点

### leetcode-数据库-183-从不订购的客户

- 题意

  `Customers` 表：

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | name        | varchar |
  +-------------+---------+
  在 SQL 中，id 是该表的主键。
  该表的每一行都表示客户的 ID 和名称。
  ```

  `Orders` 表：

  ```
  +-------------+------+
  | Column Name | Type |
  +-------------+------+
  | id          | int  |
  | customerId  | int  |
  +-------------+------+
  在 SQL 中，id 是该表的主键。
  customerId 是 Customers 表中 ID 的外键( Pandas 中的连接键)。
  该表的每一行都表示订单的 ID 和订购该订单的客户的 ID。
  ```

  找出所有从不点任何东西的顾客。

  以 **任意顺序** 返回结果表。

  结果格式如下所示。

  **示例 1：**

  ```
  输入：
  Customers table:
  +----+-------+
  | id | name  |
  +----+-------+
  | 1  | Joe   |
  | 2  | Henry |
  | 3  | Sam   |
  | 4  | Max   |
  +----+-------+
  Orders table:
  +----+------------+
  | id | customerId |
  +----+------------+
  | 1  | 3          |
  | 2  | 1          |
  +----+------------+
  输出：
  +-----------+
  | Customers |
  +-----------+
  | Henry     |
  | Max       |
  +-----------+
  ```

- 解答示例

- 要点

### leetcode-数据库-196-删除重复的电子邮箱

- 题意

  表: `Person`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | email       | varchar |
  +-------------+---------+
  id 是该表的主键列(具有唯一值的列)。
  该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。
  ```

  编写解决方案 **删除** 所有重复的电子邮件，只保留一个具有最小 `id` 的唯一电子邮件。

  （对于 SQL 用户，请注意你应该编写一个 `DELETE` 语句而不是 `SELECT` 语句。）

  （对于 Pandas 用户，请注意你应该直接修改 `Person` 表。）

  运行脚本后，显示的答案是 `Person` 表。驱动程序将首先编译并运行您的代码片段，然后再显示 `Person` 表。`Person` 表的最终顺序 **无关紧要** 。

  返回结果格式如下示例所示。

  **示例 1:**

  ```
  输入: 
  Person 表:
  +----+------------------+
  | id | email            |
  +----+------------------+
  | 1  | john@example.com |
  | 2  | bob@example.com  |
  | 3  | john@example.com |
  +----+------------------+
  输出: 
  +----+------------------+
  | id | email            |
  +----+------------------+
  | 1  | john@example.com |
  | 2  | bob@example.com  |
  +----+------------------+
  解释: john@example.com重复两次。我们保留最小的Id = 1。
  ```

- 解答示例

- 要点

### leetcode-数据库-197-上升的温度

- 题意

  表： `Weather`

  ```
  +---------------+---------+
  | Column Name   | Type    |
  +---------------+---------+
  | id            | int     |
  | recordDate    | date    |
  | temperature   | int     |
  +---------------+---------+
  id 是该表具有唯一值的列。
  该表包含特定日期的温度信息
  ```

  编写解决方案，找出与之前（昨天的）日期相比温度更高的所有日期的 `id` 。

  返回结果 **无顺序要求** 。

  结果格式如下例子所示。

  **示例 1：**

  ```
  输入：
  Weather 表：
  +----+------------+-------------+
  | id | recordDate | Temperature |
  +----+------------+-------------+
  | 1  | 2015-01-01 | 10          |
  | 2  | 2015-01-02 | 25          |
  | 3  | 2015-01-03 | 20          |
  | 4  | 2015-01-04 | 30          |
  +----+------------+-------------+
  输出：
  +----+
  | id |
  +----+
  | 2  |
  | 4  |
  +----+
  解释：
  2015-01-02 的温度比前一天高（10 -> 25）
  2015-01-04 的温度比前一天高（20 -> 30）
  ```

- 解答示例

- 要点

### leetcode-数据库-511-游戏玩法分析Ⅰ

- 题意

  活动表 `Activity`：

  ```
  +--------------+---------+
  | Column Name  | Type    |
  +--------------+---------+
  | player_id    | int     |
  | device_id    | int     |
  | event_date   | date    |
  | games_played | int     |
  +--------------+---------+
  在 SQL 中，表的主键是 (player_id, event_date)。
  这张表展示了一些游戏玩家在游戏平台上的行为活动。
  每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。
  ```

  查询每位玩家 **第一次登陆平台的日期**。

  查询结果的格式如下所示：

  ```
  Activity 表：
  +-----------+-----------+------------+--------------+
  | player_id | device_id | event_date | games_played |
  +-----------+-----------+------------+--------------+
  | 1         | 2         | 2016-03-01 | 5            |
  | 1         | 2         | 2016-05-02 | 6            |
  | 2         | 3         | 2017-06-25 | 1            |
  | 3         | 1         | 2016-03-02 | 0            |
  | 3         | 4         | 2018-07-03 | 5            |
  +-----------+-----------+------------+--------------+
  
  Result 表：
  +-----------+-------------+
  | player_id | first_login |
  +-----------+-------------+
  | 1         | 2016-03-01  |
  | 2         | 2017-06-25  |
  | 3         | 2016-03-02  |
  +-----------+-------------+
  ```

- 解答示例

- 要点

### leetcode-数据库-577-员工奖金

- 题意

  表：`Employee` 

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | empId       | int     |
  | name        | varchar |
  | supervisor  | int     |
  | salary      | int     |
  +-------------+---------+
  empId 是该表中具有唯一值的列。
  该表的每一行都表示员工的姓名和 id，以及他们的工资和经理的 id。
  ```

  表：`Bonus`

  ```
  +-------------+------+
  | Column Name | Type |
  +-------------+------+
  | empId       | int  |
  | bonus       | int  |
  +-------------+------+
  empId 是该表具有唯一值的列。
  empId 是 Employee 表中 empId 的外键(reference 列)。
  该表的每一行都包含一个员工的 id 和他们各自的奖金。
  ```

  编写解决方案，报告每个奖金 **少于** `1000` 的员工的姓名和奖金数额。

  以 **任意顺序** 返回结果表。

  结果格式如下所示。

  **示例 1：**

  ```
  输入：
  Employee table:
  +-------+--------+------------+--------+
  | empId | name   | supervisor | salary |
  +-------+--------+------------+--------+
  | 3     | Brad   | null       | 4000   |
  | 1     | John   | 3          | 1000   |
  | 2     | Dan    | 3          | 2000   |
  | 4     | Thomas | 3          | 4000   |
  +-------+--------+------------+--------+
  Bonus table:
  +-------+-------+
  | empId | bonus |
  +-------+-------+
  | 2     | 500   |
  | 4     | 2000  |
  +-------+-------+
  输出：
  +------+-------+
  | name | bonus |
  +------+-------+
  | Brad | null  |
  | John | null  |
  | Dan  | 500   |
  +------+-------+
  ```

- 解答示例

- 要点

### leetcode-数据库-584-寻找用户推荐人

- 题意

  表: `Customer`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | id          | int     |
  | name        | varchar |
  | referee_id  | int     |
  +-------------+---------+
  在 SQL 中，id 是该表的主键列。
  该表的每一行表示一个客户的 id、姓名以及推荐他们的客户的 id。
  ```

  找出那些 **没有被** `id = 2` 的客户 **推荐** 的客户的姓名。

  以 **任意顺序** 返回结果表。

  结果格式如下所示。

  **示例 1：**

  ```
  输入： 
  Customer 表:
  +----+------+------------+
  | id | name | referee_id |
  +----+------+------------+
  | 1  | Will | null       |
  | 2  | Jane | null       |
  | 3  | Alex | 2          |
  | 4  | Bill | null       |
  | 5  | Zack | 1          |
  | 6  | Mark | 2          |
  +----+------+------------+
  输出：
  +------+
  | name |
  +------+
  | Will |
  | Jane |
  | Bill |
  | Zack |
  +------+
  ```

- 解答示例

- 要点

### leetcode-数据库-586-订单最多的用户

- 题意

  表: `Orders`

  ```
  +-----------------+----------+
  | Column Name     | Type     |
  +-----------------+----------+
  | order_number    | int      |
  | customer_number | int      |
  +-----------------+----------+
  在 SQL 中，Order_number是该表的主键。
  此表包含关于订单ID和客户ID的信息。
  ```

  查找下了 **最多订单** 的客户的 `customer_number` 。

  测试用例生成后， **恰好有一个客户** 比任何其他客户下了更多的订单。

  查询结果格式如下所示。

  **示例 1:**

  ```
  输入: 
  Orders 表:
  +--------------+-----------------+
  | order_number | customer_number |
  +--------------+-----------------+
  | 1            | 1               |
  | 2            | 2               |
  | 3            | 3               |
  | 4            | 3               |
  +--------------+-----------------+
  输出: 
  +-----------------+
  | customer_number |
  +-----------------+
  | 3               |
  +-----------------+
  解释: 
  customer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。
  所以结果是该顾客的 customer_number ，也就是 3 。
  ```

  **进阶：** 如果有多位顾客订单数并列最多，你能找到他们所有的 `customer_number` 吗？

- 解答示例

- 要点

### leetcode-数据库-595-大的国家

- 题意

  `World` 表：

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | name        | varchar |
  | continent   | varchar |
  | area        | int     |
  | population  | int     |
  | gdp         | bigint  |
  +-------------+---------+
  name 是该表的主键（具有唯一值的列）。
  这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。
  ```

  如果一个国家满足下述两个条件之一，则认为该国是 **大国** ：

  - 面积至少为 300 万平方公里（即，`3000000 km2`），或者
  - 人口至少为 2500 万（即 `25000000`）

  编写解决方案找出 **大国** 的国家名称、人口和面积。

  按 **任意顺序** 返回结果表。

  返回结果格式如下例所示。

  **示例：**

  ```
  输入：
  World 表：
  +-------------+-----------+---------+------------+--------------+
  | name        | continent | area    | population | gdp          |
  +-------------+-----------+---------+------------+--------------+
  | Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |
  | Albania     | Europe    | 28748   | 2831741    | 12960000000  |
  | Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |
  | Andorra     | Europe    | 468     | 78115      | 3712000000   |
  | Angola      | Africa    | 1246700 | 20609294   | 100990000000 |
  +-------------+-----------+---------+------------+--------------+
  输出：
  +-------------+------------+---------+
  | name        | population | area    |
  +-------------+------------+---------+
  | Afghanistan | 25500100   | 652230  |
  | Algeria     | 37100000   | 2381741 |
  +-------------+------------+---------+
  ```

- 解答示例

- 要点

### leetcode-数据库-596-超过5名学生的课

- 题意

  表: `Courses`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | student     | varchar |
  | class       | varchar |
  +-------------+---------+
  在 SQL 中，(student, class)是该表的主键列。
  该表的每一行表示学生的名字和他们注册的班级。
  ```

  查询 **至少有5个学生** 的所有班级。

  以 **任意顺序** 返回结果表。

  查询结果格式如下所示。 

  **示例 1:**

  ```
  输入: 
  Courses table:
  +---------+----------+
  | student | class    |
  +---------+----------+
  | A       | Math     |
  | B       | English  |
  | C       | Math     |
  | D       | Biology  |
  | E       | Math     |
  | F       | Computer |
  | G       | Math     |
  | H       | Math     |
  | I       | Math     |
  +---------+----------+
  输出: 
  +---------+ 
  | class   | 
  +---------+ 
  | Math    | 
  +---------+
  解释: 
  -数学课有6个学生，所以我们包括它。
  -英语课有1名学生，所以我们不包括它。
  -生物课有1名学生，所以我们不包括它。
  -计算机课有1个学生，所以我们不包括它。
  ```

- 解答示例

- 要点

### leetcode-数据库-1141-查询近30天活跃用户

- 题意

  表：`Activity`

  ```
  +---------------+---------+
  | Column Name   | Type    |
  +---------------+---------+
  | user_id       | int     |
  | session_id    | int     |
  | activity_date | date    |
  | activity_type | enum    |
  +---------------+---------+
  该表没有包含重复数据。
  activity_type 列是 ENUM(category) 类型， 从 ('open_session'， 'end_session'， 'scroll_down'， 'send_message') 取值。
  该表记录社交媒体网站的用户活动。
  注意，每个会话只属于一个用户。
  ```

  编写解决方案，统计截至 `2019-07-27`（包含2019-07-27），近 `30` 天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。

  以 **任意顺序** 返回结果表。

  结果示例如下。

  **示例 1:**

  ```
  输入：
  Activity table:
  +---------+------------+---------------+---------------+
  | user_id | session_id | activity_date | activity_type |
  +---------+------------+---------------+---------------+
  | 1       | 1          | 2019-07-20    | open_session  |
  | 1       | 1          | 2019-07-20    | scroll_down   |
  | 1       | 1          | 2019-07-20    | end_session   |
  | 2       | 4          | 2019-07-20    | open_session  |
  | 2       | 4          | 2019-07-21    | send_message  |
  | 2       | 4          | 2019-07-21    | end_session   |
  | 3       | 2          | 2019-07-21    | open_session  |
  | 3       | 2          | 2019-07-21    | send_message  |
  | 3       | 2          | 2019-07-21    | end_session   |
  | 4       | 3          | 2019-06-25    | open_session  |
  | 4       | 3          | 2019-06-25    | end_session   |
  +---------+------------+---------------+---------------+
  输出：
  +------------+--------------+ 
  | day        | active_users |
  +------------+--------------+ 
  | 2019-07-20 | 2            |
  | 2019-07-21 | 2            |
  +------------+--------------+ 
  解释：注意非活跃用户的记录不需要展示。
  ```

- 解答示例

- 要点

### leetcode-数据库-1633-各赛事的用户注册率

- 题意

  用户表： `Users`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | user_id     | int     |
  | user_name   | varchar |
  +-------------+---------+
  user_id 是该表的主键(具有唯一值的列)。
  该表中的每行包括用户 ID 和用户名。
  ```

  注册表： `Register`

  ```
  +-------------+---------+
  | Column Name | Type    |
  +-------------+---------+
  | contest_id  | int     |
  | user_id     | int     |
  +-------------+---------+
  (contest_id, user_id) 是该表的主键(具有唯一值的列的组合)。
  该表中的每行包含用户的 ID 和他们注册的赛事。
  ```

  编写解决方案统计出各赛事的用户注册百分率，保留两位小数。

  返回的结果表按 `percentage` 的 **降序** 排序，若相同则按 `contest_id` 的 **升序** 排序。

  返回结果如下示例所示。

  **示例 1：**

  ```
  输入：
  Users 表：
  +---------+-----------+
  | user_id | user_name |
  +---------+-----------+
  | 6       | Alice     |
  | 2       | Bob       |
  | 7       | Alex      |
  +---------+-----------+
  
  Register 表：
  +------------+---------+
  | contest_id | user_id |
  +------------+---------+
  | 215        | 6       |
  | 209        | 2       |
  | 208        | 2       |
  | 210        | 6       |
  | 208        | 6       |
  | 209        | 7       |
  | 209        | 6       |
  | 215        | 7       |
  | 208        | 7       |
  | 210        | 2       |
  | 207        | 2       |
  | 210        | 7       |
  +------------+---------+
  输出：
  +------------+------------+
  | contest_id | percentage |
  +------------+------------+
  | 208        | 100.0      |
  | 209        | 100.0      |
  | 210        | 100.0      |
  | 215        | 66.67      |
  | 207        | 33.33      |
  +------------+------------+
  解释：
  所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。
  Alice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%
  Bob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%
  ```

- 解答示例

- 要点

### leetcode-数据库-1527-患某种疾病的患者

- 题意

  患者信息表： `Patients`

  ```
  +--------------+---------+
  | Column Name  | Type    |
  +--------------+---------+
  | patient_id   | int     |
  | patient_name | varchar |
  | conditions   | varchar |
  +--------------+---------+
  在 SQL 中，patient_id （患者 ID）是该表的主键。
  'conditions' （疾病）包含 0 个或以上的疾病代码，以空格分隔。
  这个表包含医院中患者的信息。
  ```

  查询患有 I类糖尿病的患者 ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀 `DIAB1` 。

  按 **任意顺序** 返回结果表。

  查询结果格式如下示例所示。

  **示例 1:**

  ```
  输入：
  Patients表：
  +------------+--------------+--------------+
  | patient_id | patient_name | conditions   |
  +------------+--------------+--------------+
  | 1          | Daniel       | YFEV COUGH   |
  | 2          | Alice        |              |
  | 3          | Bob          | DIAB100 MYOP |
  | 4          | George       | ACNE DIAB100 |
  | 5          | Alain        | DIAB201      |
  +------------+--------------+--------------+
  输出：
  +------------+--------------+--------------+
  | patient_id | patient_name | conditions   |
  +------------+--------------+--------------+
  | 3          | Bob          | DIAB100 MYOP |
  | 4          | George       | ACNE DIAB100 | 
  +------------+--------------+--------------+
  解释：Bob 和 George 都患有代码以 DIAB1 开头的疾病。
  ```

- 解答示例

- 要点

### leetcode-数据库-610-判断三角形

- 题意

  表: `Triangle`

  ```
  +-------------+------+
  | Column Name | Type |
  +-------------+------+
  | x           | int  |
  | y           | int  |
  | z           | int  |
  +-------------+------+
  在 SQL 中，(x, y, z)是该表的主键列。
  该表的每一行包含三个线段的长度。
  ```

  对每三个线段报告它们是否可以形成一个三角形。

  以 **任意顺序** 返回结果表。

  查询结果格式如下所示。

  **示例 1:**

  ```
  输入: 
  Triangle 表:
  +----+----+----+
  | x  | y  | z  |
  +----+----+----+
  | 13 | 15 | 30 |
  | 10 | 20 | 15 |
  +----+----+----+
  输出: 
  +----+----+----+----------+
  | x  | y  | z  | triangle |
  +----+----+----+----------+
  | 13 | 15 | 30 | No       |
  | 10 | 20 | 15 | Yes      |
  +----+----+----+----------+
  ```

- 解答示例

- 要点

### leetcode-数据库-1407-排名靠前的旅行者

- 题意

  表：`Users`

  ```
  +---------------+---------+
  | Column Name   | Type    |
  +---------------+---------+
  | id            | int     |
  | name          | varchar |
  +---------------+---------+
  id 是该表中具有唯一值的列。
  name 是用户名字。
  ```

  表：`Rides`

  ```
  +---------------+---------+
  | Column Name   | Type    |
  +---------------+---------+
  | id            | int     |
  | user_id       | int     |
  | distance      | int     |
  +---------------+---------+
  id 是该表中具有唯一值的列。
  user_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance 。
  ```

  编写解决方案，报告每个用户的旅行距离。

  返回的结果表单，以 `travelled_distance` **降序排列** ，如果有两个或者更多的用户旅行了相同的距离, 那么再以 `name` **升序排列** 。

  返回结果格式如下例所示。

  **示例 1：**

  ```
  输入：
  Users 表：
  +------+-----------+
  | id   | name      |
  +------+-----------+
  | 1    | Alice     |
  | 2    | Bob       |
  | 3    | Alex      |
  | 4    | Donald    |
  | 7    | Lee       |
  | 13   | Jonathan  |
  | 19   | Elvis     |
  +------+-----------+
  
  Rides 表：
  +------+----------+----------+
  | id   | user_id  | distance |
  +------+----------+----------+
  | 1    | 1        | 120      |
  | 2    | 2        | 317      |
  | 3    | 3        | 222      |
  | 4    | 7        | 100      |
  | 5    | 13       | 312      |
  | 6    | 19       | 50       |
  | 7    | 7        | 120      |
  | 8    | 19       | 400      |
  | 9    | 7        | 230      |
  +------+----------+----------+
  输出：
  +----------+--------------------+
  | name     | travelled_distance |
  +----------+--------------------+
  | Elvis    | 450                |
  | Lee      | 450                |
  | Bob      | 317                |
  | Jonathan | 312                |
  | Alex     | 222                |
  | Alice    | 120                |
  | Donald   | 0                  |
  +----------+--------------------+
  解释：
  Elvis 和 Lee 旅行了 450 英里，Elvis 是排名靠前的旅行者，因为他的名字在字母表上的排序比 Lee 更小。
  Bob, Jonathan, Alex 和 Alice 只有一次行程，我们只按此次行程的全部距离对他们排序。
  Donald 没有任何行程, 他的旅行距离为 0。
  ```

- 解答示例

- 要点

### leetcode-数据库-1731-每名经理的下属员工数量

- 题意

  Table: `Employees`

  ```
  +-------------+----------+
  | Column Name | Type     |
  +-------------+----------+
  | employee_id | int      |
  | name        | varchar  |
  | reports_to  | int      |
  | age         | int      |
  +-------------+----------+
  employee_id 是这个表的主键.
  该表包含员工以及需要听取他们汇报的上级经理的ID的信息。 有些员工不需要向任何人汇报（reports_to 为空）。
  ```

  对于此问题，我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。

  编写SQL查询需要听取汇报的所有经理的ID、名称、直接向该经理汇报的员工人数，以及这些员工的平均年龄，其中该平均年龄需要四舍五入到最接近的整数。

  返回的结果集需要按照 `employee_id `进行排序。

  查询结果的格式如下：

  ```
  Employees table:
  +-------------+---------+------------+-----+
  | employee_id | name    | reports_to | age |
  +-------------+---------+------------+-----+
  | 9           | Hercy   | null       | 43  |
  | 6           | Alice   | 9          | 41  |
  | 4           | Bob     | 9          | 36  |
  | 2           | Winston | null       | 37  |
  +-------------+---------+------------+-----+
  
  Result table:
  +-------------+-------+---------------+-------------+
  | employee_id | name  | reports_count | average_age |
  +-------------+-------+---------------+-------------+
  | 9           | Hercy | 2             | 39          |
  +-------------+-------+---------------+-------------+
  Hercy 有两个需要向他汇报的员工, 他们是 Alice and Bob. 他们的平均年龄是 (41+36)/2 = 38.5, 四舍五入的结果是 39.
  ```

- 解答示例

- 要点

### leetcode-数据库-1484-按日期分组销售产品

- 题意

  表 `Activities`：

  ```
  +-------------+---------+
  | 列名         | 类型    |
  +-------------+---------+
  | sell_date   | date    |
  | product     | varchar |
  +-------------+---------+
  该表没有主键(具有唯一值的列)。它可能包含重复项。
  此表的每一行都包含产品名称和在市场上销售的日期。
  ```

  编写解决方案找出每个日期、销售的不同产品的数量及其名称。
  每个日期的销售产品名称应按词典序排列。
  返回按 `sell_date` 排序的结果表。
  结果表结果格式如下例所示。

  **示例 1:**

  ```
  输入：
  Activities 表：
  +------------+-------------+
  | sell_date  | product     |
  +------------+-------------+
  | 2020-05-30 | Headphone   |
  | 2020-06-01 | Pencil      |
  | 2020-06-02 | Mask        |
  | 2020-05-30 | Basketball  |
  | 2020-06-01 | Bible       |
  | 2020-06-02 | Mask        |
  | 2020-05-30 | T-Shirt     |
  +------------+-------------+
  输出：
  +------------+----------+------------------------------+
  | sell_date  | num_sold | products                     |
  +------------+----------+------------------------------+
  | 2020-05-30 | 3        | Basketball,Headphone,T-shirt |
  | 2020-06-01 | 2        | Bible,Pencil                 |
  | 2020-06-02 | 1        | Mask                         |
  +------------+----------+------------------------------+
  解释：
  对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 ',' 分隔。
  对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。
  对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。
  ```

- 解答示例

- 要点

### leetcode-数据库-1517-查找拥有有效邮箱的用户

- 题意

  表: `Users`

  ```
  +---------------+---------+
  | Column Name   | Type    |
  +---------------+---------+
  | user_id       | int     |
  | name          | varchar |
  | mail          | varchar |
  +---------------+---------+
  user_id 是该表的主键（具有唯一值的列）。
  该表包含了网站已注册用户的信息。有一些电子邮件是无效的。
  ```

  编写一个解决方案，以查找具有有效电子邮件的用户。

  一个有效的电子邮件具有前缀名称和域，其中：

  1.  **前缀** 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 `'_'` ，点 `'.'` 和/或破折号 `'-'` 。前缀名称 **必须** 以字母开头。
  2. **域** 为 `'@leetcode.com'` 。

  以任何顺序返回结果表。

  结果的格式如以下示例所示：

  **示例 1：**

  ```
  输入：
  Users 表:
  +---------+-----------+-------------------------+
  | user_id | name      | mail                    |
  +---------+-----------+-------------------------+
  | 1       | Winston   | winston@leetcode.com    |
  | 2       | Jonathan  | jonathanisgreat         |
  | 3       | Annabelle | bella-@leetcode.com     |
  | 4       | Sally     | sally.come@leetcode.com |
  | 5       | Marwan    | quarz#2020@leetcode.com |
  | 6       | David     | david69@gmail.com       |
  | 7       | Shapiro   | .shapo@leetcode.com     |
  +---------+-----------+-------------------------+
  输出：
  +---------+-----------+-------------------------+
  | user_id | name      | mail                    |
  +---------+-----------+-------------------------+
  | 1       | Winston   | winston@leetcode.com    |
  | 3       | Annabelle | bella-@leetcode.com     |
  | 4       | Sally     | sally.come@leetcode.com |
  +---------+-----------+-------------------------+
  解释：
  用户 2 的电子邮件没有域。 
  用户 5 的电子邮件带有不允许的 '#' 符号。
  用户 6 的电子邮件没有 leetcode 域。 
  用户 7 的电子邮件以点开头。
  ```

- 解答示例

- 要点